---
title: Plugins
description: Extend Callapi's functionality with plugins
---

Plugins extend CallApi with reusable functionality like authentication, logging, caching, or custom request/response handling. They can modify requests before they're sent, intercept the fetch call, and hook into the request lifecycle.

## Creating a Plugin

Use the `definePlugin` helper for type-safe plugin creation:

```ts twoslash title="plugins.ts"
import { createFetchClient } from "@zayne-labs/callapi";
import { definePlugin } from "@zayne-labs/callapi/utils";

const envPlugin = definePlugin({
	id: "env-plugin",
	name: "Environment Plugin",
	description: "Adds environment-specific headers to requests",
	version: "1.0.0",

	setup: ({ request, options, initURL }) => {
		const env = process.env.NODE_ENV || "development";

		const updatedRequest = {
			...request,
			headers: { ...request.headers, "X-Environment": env },
		};

		const updatedOptions = {
			...options,
			meta: {
				...options.meta,
				env,
			},
		};

		const updatedInitURL = initURL.replace("http://localhost:3000", "http://localhost:3001");

		return {
			initURL: updatedInitURL,
			options: updatedOptions,
			request: updatedRequest,
		};
	},
});

const callBackendApi = createFetchClient({
	baseURL: "http://localhost:3000",
	plugins: [envPlugin],
});
```

Or alternatively, you can also use TypeScript's `satisfies` keyword together with `CallApiPlugin` type to achieve the same effect:

```ts twoslash title="plugins.ts"
import type { CallApiPlugin } from "@zayne-labs/callapi";

const envPlugin = {
	id: "env-plugin",
	name: "Environment Plugin",
	description: "Adds environment-specific headers to requests",
	version: "1.0.0",

	setup: ({ request }) => {
		const env = process.env.NODE_ENV || "development";

		const updatedRequest = {
			...request,
			headers: { ...request.headers, "X-Environment": env },
		};

		return {
			request: updatedRequest,
		};
	},
} satisfies CallApiPlugin;
```

## Using Plugins

### Base Plugins

Add plugins when creating a client to apply them to all requests:

```ts title="api.ts"
const callBackendApi = createFetchClient({
	plugins: [
		envPlugin, // Handle environment-specific configurations
		loggingPlugin, // Log request/response details
	],
});
```

### Per-Request Plugins

Add plugins to individual requests for specific calls:

```ts title="api.ts"
const { data } = await callBackendApi("/users", {
	plugins: [metricsPlugin],
});
```

<Callout type="info">
	By default, passing `plugins` to a request replaces base plugins. To keep base plugins and add new ones,
	use a callback.
</Callout>

```ts title="api.ts"
import { createFetchClient } from "@zayne-labs/callapi";
import { metricsPlugin, envPlugin, loggingPlugin } from "./plugins";

const callBackendApi = createFetchClient({
	plugins: [envPlugin, loggingPlugin],
});

const { data } = await callBackendApi("/users", {
	plugins: ({ basePlugins }) => [...basePlugins, metricsPlugin], // Add metrics plugin while keeping base plugins
});
```

## Plugin Anatomy

### Setup Function

The `setup` function runs before any request processing begins. It receives the initial URL, options, and request, and can return modified versions of these values. This is useful for transforming requests before CallApi's internal processing.

```ts twoslash title="plugins.ts"
import { definePlugin } from "@zayne-labs/callapi/utils";

const envPlugin = definePlugin({
	id: "env-plugin",
	name: "Environment Plugin",
	description: "A plugin that adds environment-specific headers to requests",
	version: "1.0.0",

	setup: ({ request }) => {
		const env = process.env.NODE_ENV ?? "development";
		const platform = typeof window !== "undefined" ? "browser" : "node";
		const timezone = Intl.DateTimeFormat().resolvedOptions().timeZone;

		const updatedRequest = {
			...request,
			headers: {
				...request.headers,
				"X-Environment": env,
				"X-Client-Platform": platform,
				"X-Client-Timezone": timezone,
			},
		};

		return {
			request: updatedRequest,
		};
	},
});
```

### Defining Extra Options

Plugins can define custom options that users can pass to `callApi`. Use `defineExtraOptions` to return a validation schema (like Zod) that defines these options.

Here's a plugin that adds an `apiVersion` option to automatically set the API version header:

```ts twoslash title="plugins.ts"
import { createFetchClient, type PluginSetupContext } from "@zayne-labs/callapi";
import { definePlugin } from "@zayne-labs/callapi/utils";
import { z } from "zod";

const apiVersionSchema = z.object({
	apiVersion: z.literal(["v1", "v2", "v3"]).optional(),
});

const apiVersionPlugin = definePlugin({
	id: "api-version-plugin",
	name: "API Version Plugin",
	description: "Adds API version header to requests",
	version: "1.0.0",

	defineExtraOptions: () => apiVersionSchema,

	setup: (ctx: PluginSetupContext<{ InferredExtraOptions: z.infer<typeof apiVersionSchema> }>) => {
		const version = ctx.options.apiVersion ?? "v1";

		return {
			request: {
				...ctx.request,
				headers: { ...ctx.request.headers, "X-API-Version": version },
			},
		};
	},
});

const callBackendApi = createFetchClient({
	baseURL: "https://api.example.com",
	plugins: [apiVersionPlugin],
	apiVersion: "v2", // Default for all requests
});

// Use default v2
const { data: users } = await callBackendApi("/users");

// Override to v3 for this request
const { data: posts } = await callBackendApi("/posts", {
	apiVersion: "v3",
});
```

The Zod schema validates the `apiVersion` option, making it available in the `setup` function with full type safety.

### Hooks

Plugins can define hooks that run at different stages of the request lifecycle. Hooks can be an object or a function that returns an object (useful for accessing setup context). See [Hooks](./hooks) for detailed information about available hooks.

```ts twoslash title="plugins.ts"
import { createFetchClient } from "@zayne-labs/callapi";
import { definePlugin } from "@zayne-labs/callapi/utils";

const myPlugin = definePlugin({
	id: "my-plugin",
	name: "My Plugin",
	description: "A plugin that does something",
	version: "1.0.0",

	hooks: {
		onError: (ctx) => {
			// Do something with context object
		},
		onSuccess: (ctx) => {
			// Do something with context object
		},

		// More hooks can be added here
	},
});

const callBackendApi = createFetchClient({
	baseURL: "http://localhost:3000",
	plugins: [myPlugin],
});
```

**Dynamic Hooks:**

Hooks can also be a function that receives the plugin setup context:

```ts twoslash title="plugins.ts"
import { definePlugin } from "@zayne-labs/callapi/utils";

const dynamicPlugin = definePlugin({
	id: "dynamic-plugin",
	name: "Dynamic Plugin",

	hooks: (context) => {
		const startTime = Date.now();

		return {
			onSuccess: () => {
				console.log(`Request to ${context.initURL} took ${Date.now() - startTime}ms`);
			},
		};
	},
});
```

<Callout type="info">
	When multiple plugins are registered, their `setup` functions and hooks execute in the order they appear
	in the plugins array.
</Callout>

### Middleware

Plugins can define middleware to wrap internal operations. Currently, CallApi supports fetch middleware for intercepting requests at the network layer. See [Middleware](./middlewares) for detailed information.

Define middleware using the `middlewares` property. Like hooks, middlewares can be an object or a function that receives the setup context.

**Static Middleware:**

```ts title="plugins.ts"
import { definePlugin } from "@zayne-labs/callapi/utils";

const loggingPlugin = definePlugin({
	id: "logging",
	name: "Logging Plugin",
	version: "1.0.0",

	middlewares: {
		fetchMiddleware: (ctx) => async (input, init) => {
			console.log("→", init?.method || "GET", input);
			const response = await ctx.fetchImpl(input, init);
			console.log("←", response.status, input);
			return response;
		},
	},
});
```

**Dynamic Middleware:**

Middlewares can also be a function that receives the plugin setup context:

```ts twoslash title="plugins.ts"
import { type PluginSetupContext } from "@zayne-labs/callapi";
import { definePlugin } from "@zayne-labs/callapi/utils";

const cachingPlugin = definePlugin({
	id: "caching",
	name: "Caching Plugin",
	version: "1.0.0",

	middlewares: (context: PluginSetupContext) => {
		const cache = new Map<string, Response>();

		return {
			fetchMiddleware: (ctx) => async (input, init) => {
				const key = input.toString();

				if (cache.has(key)) {
					return cache.get(key)!.clone();
				}

				const response = await ctx.fetchImpl(input, init);
				cache.set(key, response.clone());
				return response;
			},
		};
	},
});
```

## Example: Metrics Plugin

Here's a complete example of a plugin that tracks API metrics:

```ts title="plugins.ts"
import { definePlugin } from "@zayne-labs/callapi/utils";

declare module "@zayne-labs/callapi" {
	interface Register {
		meta: {
			startTime: number;
		};
	}
}

const metricsPlugin = definePlugin({
	id: "metrics",
	name: "Metrics Plugin",
	description: "Tracks API response times and success rates",

	setup: ({ initURL, options }) => {
		console.info(`Starting request to ${initURL}`);

		const startTime = performance.now();

		return {
			options: {
				...options,
				meta: { startTime },
			},
		};
	},

	hooks: {
		onSuccess: ({ options }) => {
			const startTime = options.meta?.startTime ?? 0;
			const duration = performance.now() - startTime;

			console.info(`Request completed in ${duration}ms`);
		},

		onError: ({ error, options }) => {
			const startTime = options.meta?.startTime ?? 0;
			const duration = performance.now() - startTime;

			console.error(`Request failed after ${duration}ms:`, error);
		},
	},
});
```

## Types

<auto-type-table path="../../lib/callapi-options.ts" name="CallApiPlugin" />
