---
title: Plugins
description: Extend Callapi's functionality with plugins
---

Plugins allow you to extend `CallApi` with extra functionality.

## Creating a Plugin

To provide type safety when creating a plugin, you can use the `definePlugin` helper:

```ts twoslash title="plugins.ts"
import { definePlugin, createFetchClient } from "@zayne-labs/callapi";

const envPlugin = definePlugin({
	id: "env-plugin",
	name: "Environment Plugin",
	description: "Adds environment-specific headers to requests",
	version: "1.0.0",

	setup: ({ request, options, initURL }) => {
		const env = process.env.NODE_ENV || "development";

		const updatedRequest = {
			...request,
			headers: { ...request.headers, "X-Environment": env },
		};

		const updatedOptions = {
			...options,
			meta: {
				...options.meta,
				env,
			},
		};

		const updatedInitURL = initURL.replace("http://localhost:3000", "http://localhost:3001");

		return {
			initURL: updatedInitURL,
			options: updatedOptions,
			request: updatedRequest,
		};
	},
});

const callBackendApi = createFetchClient({
	baseURL: "http://localhost:3000",
	plugins: [envPlugin],
});
```

Or alternatively, you can also use TypeScript's `satisfies` keyword together with `CallApiPlugin` type to achieve the same effect:

```ts twoslash title="plugins.ts"
import type { CallApiPlugin } from "@zayne-labs/callapi";

const envPlugin = {
	id: "env-plugin",
	name: "Environment Plugin",
	description: "Adds environment-specific headers to requests",
	version: "1.0.0",

	setup: ({ request }) => {
		const env = process.env.NODE_ENV || "development";

		const updatedRequest = {
			...request,
			headers: { ...request.headers, "X-Environment": env },
		};

		return {
			request: updatedRequest,
		};
	},
} satisfies CallApiPlugin;
```

### Setup Function

The `setup` function is called before the request is made and any of CallApi's internal functions are called. It takes the url, options, and request as arguments and is expected to return the modified url, options and request if necessary.

```ts twoslash title="plugins.ts"
import { definePlugin } from "@zayne-labs/callapi";

// ---cut---
const envPlugin = definePlugin({
	id: "env-plugin",
	name: "Environment Plugin",
	description: "A plugin that adds environment-specific headers to requests",
	version: "1.0.0",

	setup: ({ request }) => {
		const env = process.env.NODE_ENV ?? "development";
		const platform = typeof window !== "undefined" ? "browser" : "node";
		const timezone = Intl.DateTimeFormat().resolvedOptions().timeZone;

		const updatedRequest = {
			...request,
			headers: {
				...request.headers,
				"X-Environment": env,
				"X-Client-Platform": platform,
				"X-Client-Timezone": timezone,
			},
		};

		return {
			request: updatedRequest,
		};
	},
});
```

### Hooks

Hooks are callback functions that are called at different stages of the request lifecycle. See [Hooks](./hooks) for more information.

```ts twoslash title="plugins.ts"
import { definePlugin, createFetchClient } from "@zayne-labs/callapi";

const myPlugin = definePlugin({
	id: "my-plugin",
	name: "My Plugin",
	description: "A plugin that does something",
	version: "1.0.0",

	hooks: {
		onError: (ctx) => {
			// Do something with context object
		},
		onSuccess: (ctx) => {
			// Do something with context object
		},

		// More hooks can be added here
	},
});

const callBackendApi = createFetchClient({
	baseURL: "http://localhost:3000",
	plugins: [myPlugin],
});
```

<Callout type="info">
	If more than one plugin is registered, the `setup` and `hooks` for each plugin will be called in the
	order they are registered.
</Callout>

### Fetch Middleware

Plugins can define fetch middleware to wrap the native fetch function, enabling powerful features like caching, upload/download progress tracking, and request interception. Unlike `customFetchImpl` which replaces fetch entirely, middlewares compose together automatically.

```ts
type FetchMiddleware = (fetchImpl: FetchImpl) => FetchImpl;
```

#### Creating Plugin Middlewares

Use the `middlewares` property to define fetch middleware in your plugin:

**Example: Response Caching Plugin**

```ts twoslash title="plugins.ts"
import { definePlugin, type PluginSetupContext } from "@zayne-labs/callapi";
import { z } from "zod";

const CacheExtraOptionsSchema = z.object({
	cachePolicy: z.enum(["cache-first", "no-cache"]).default("cache-first"),
	cacheLifetimeMs: z.number().int().positive().default(60_000),
});

const cachingPlugin = definePlugin(() => ({
	id: "caching-plugin",
	name: "Caching Plugin",
	version: "1.0.0",

	defineExtraOptions: () => CacheExtraOptionsSchema,

	middlewares: ({ options }: PluginSetupContext<z.infer<typeof CacheExtraOptionsSchema>>) => {
		const cache = new Map<string, { data: Response; timestamp: number }>();
		const cacheLifetime = options.cacheLifetimeMs;
		const cachePolicy = options.cachePolicy;

		return {
			fetchMiddleware: (fetchImpl) => async (input, init) => {
				if (cachePolicy === "no-cache") {
					return fetchImpl(input, init);
				}

				const cacheKey = input.toString();
				const cached = cache.get(cacheKey);

				// Return cached response if still valid
				if (cached && Date.now() - cached.timestamp < cacheLifetime) {
					console.info(`Cache hit: ${cacheKey}`);
					return cached.data.clone();
				}

				// Fetch and cache the response
				console.info(`Cache miss: ${cacheKey}`);
				const response = await fetchImpl(input, init);

				if (response.ok) {
					cache.set(cacheKey, {
						data: response.clone(),
						timestamp: Date.now(),
					});
				}

				return response;
			},
		};
	},
}));
```

**Example: Upload Progress with XHR**

```ts twoslash title="plugins.ts"
import { definePlugin } from "@zayne-labs/callapi";
import { z } from "zod/v3";

const uploadProgressPlugin = definePlugin({
	id: "upload-progress",
	name: "Upload Progress Plugin",
	version: "1.0.0",

	defineExtraOptions: () =>
		z.object({
			onUploadProgress: z
				.function()
				.args(z.object({ loaded: z.number(), total: z.number() }))
				.optional(),
		}),

	middlewares: ({ options }) => ({
		fetchMiddleware: (fetchImpl) => async (input, init) => {
			// Only intercept if onUploadProgress is provided
			if (!options.onUploadProgress || !init?.body) {
				return fetchImpl(input, init);
			}

			// Use XHR for upload progress tracking
			return new Promise<Response>((resolve, reject) => {
				const xhr = new XMLHttpRequest();
				const url = typeof input === "string" ? input : input.toString();

				xhr.open(init.method || "POST", url);

				// Copy headers
				if (init.headers) {
					const headers = new Headers(init.headers);
					headers.forEach((value, key) => xhr.setRequestHeader(key, value));
				}

				xhr.upload.addEventListener("progress", (event) => {
					if (event.lengthComputable) {
						options.onUploadProgress?.({ loaded: event.loaded, total: event.total });
					}
				});

				xhr.onload = () => {
					resolve(
						new Response(xhr.response, {
							status: xhr.status,
							statusText: xhr.statusText,
						})
					);
				};

				xhr.onerror = () => reject(new Error("Upload failed"));
				xhr.send(init.body as XMLHttpRequestBodyInit);
			});
		},
	}),
});
```

**Example: Offline Detection**

```ts twoslash title="plugins.ts"
import { definePlugin } from "@zayne-labs/callapi";

const offlinePlugin = definePlugin({
	id: "offline-plugin",
	name: "Offline Plugin",
	version: "1.0.0",

	middlewares: {
		fetchMiddleware: (fetchImpl) => async (input, init) => {
			if (!navigator.onLine) {
				return new Response(JSON.stringify({ error: "No internet connection" }), {
					status: 503,
					headers: { "Content-Type": "application/json" },
				});
			}

			return fetchImpl(input, init);
		},
	},
});
```

#### Middleware Composition

Middlewares compose automatically in this order: **Per-request → Plugins (reverse) → Base → customFetchImpl → fetch**

```ts
const client = createFetchClient({
	plugins: [cachingPlugin, loggingPlugin],
});

// Execution: Per-request → loggingPlugin → cachingPlugin → Base → fetch
```

**Example: Download Progress with Streams**

```ts twoslash title="plugins.ts"
import { definePlugin } from "@zayne-labs/callapi";
import { z } from "zod/v3";

const downloadProgressPlugin = definePlugin({
	id: "download-progress",
	name: "Download Progress Plugin",
	version: "1.0.0",

	defineExtraOptions: () =>
		z.object({
			onDownloadProgress: z
				.function()
				.args(z.object({ loaded: z.number(), total: z.number() }))
				.optional(),
		}),

	middlewares: ({ options }) => ({
		fetchMiddleware: (fetchImpl) => async (input, init) => {
			const response = await fetchImpl(input, init);

			if (!options.onDownloadProgress || !response.body) {
				return response;
			}

			const contentLength = response.headers.get("content-length");
			const total = contentLength ? parseInt(contentLength, 10) : 0;
			let loaded = 0;

			const reader = response.body.getReader();
			const stream = new ReadableStream({
				async start(controller) {
					while (true) {
						const { done, value } = await reader.read();

						if (done) break;

						loaded += value.length;
						options.onDownloadProgress?.({ loaded, total });
						controller.enqueue(value);
					}

					controller.close();
				},
			});

			return new Response(stream, {
				status: response.status,
				statusText: response.statusText,
				headers: response.headers,
			});
		},
	}),
});
```

#### Using Middleware Outside Plugins

You can also use `fetchMiddleware` at the base config or per-request level:

```ts
// Base config - applies to all requests
const client = createFetchClient({
	fetchMiddleware: (fetchImpl) => async (input, init) => {
		console.log("Request:", input);
		return fetchImpl(input, init);
	},
});

// Per-request - one-off modification
await client("/users", {
	fetchMiddleware: (fetchImpl) => async (input, init) => {
		const start = Date.now();
		const response = await fetchImpl(input, init);
		console.log(`Took ${Date.now() - start}ms`);
		return response;
	},
});
```

#### Middleware vs customFetchImpl

| Feature            | `fetchMiddleware`                 | `customFetchImpl`          |
| ------------------ | --------------------------------- | -------------------------- |
| **Composition**    | ✅ Multiple compose automatically | ❌ Single implementation   |
| **Use in plugins** | ✅ Via `middlewares` property     | ❌ No                      |
| **Use cases**      | Caching, logging, auth, retry     | Complete fetch replacement |

### Defining Extra Options

Sometimes your plugin needs to define additional callapi options beyond what is provided. To handle this, you can use the `defineExtraOptions` function to return a validation schema that defines those options.

For example, let's create a plugin that tracks upload progress and defines a custom option `onUploadProgress`:

```ts twoslash title="plugins.ts"
import { createFetchClient, definePlugin, type PluginSetupContext } from "@zayne-labs/callapi";
import { z } from "zod/v3";

const pluginOptionsSchema = z.object({
	onUploadProgress: z.function().args(z.object({ loaded: z.number(), total: z.number() })),
});

const uploadProgressPlugin = definePlugin({
	id: "upload-progress-plugin",
	name: "Upload Progress Plugin",
	description: "A plugin that tracks upload progress",
	version: "1.0.0",

	defineExtraOptions: () => pluginOptionsSchema,

	setup: ({ request, options }: PluginSetupContext<z.infer<typeof pluginOptionsSchema>>) => {
		const xhr = new XMLHttpRequest();

		xhr.open(request.method!, options.fullURL!);

		xhr.send(request.body as XMLHttpRequestBodyInit);

		xhr.upload.addEventListener("progress", (event) => {
			if (!event.lengthComputable) {
				console.error("Upload progress is not calculable");
				return;
			}

			options.onUploadProgress?.({ loaded: event.loaded, total: event.total });
		});
	},
});

const callBackendApi = createFetchClient({
	baseURL: "http://localhost:3000",
	plugins: [uploadProgressPlugin],
});

const { data } = await callBackendApi("/api/users", {
	onUploadProgress: ({ loaded, total }) => {
		console.log(`Uploaded ${loaded} bytes of ${total}`);
	},
});
```

Here we use Zod schemas to define the custom callapi option `onUploadProgress`, which is then called inside the `setup` function to set up progress tracking for XMLHttpRequest uploads.

## Using Plugins

### Adding Base Plugins

You can add plugins when creating a CallApi instance. These plugins will be applied to all requests made with that instance:

```ts title="api.ts"
const callBackendApi = createFetchClient({
	plugins: [
		envPlugin, // Handle environment-specific configurations
		loggingPlugin, // Log request/response details
	],
});
```

### Adding Plugins to Individual Requests

For specific requests, you can add plugins that will only be active for that particular call:

```ts title="api.ts"
const { data } = await callBackendApi("/users", {
	plugins: [metricsPlugin], // Only track metrics for this request
});
```

**NOTE**: Using the `plugins` option directly on the CallApi instance will replace the base plugins array by default. If you want to keep the base plugins and still be able to add new ones, pass a callback to the `plugins` option that is called with the base plugins array:

```ts title="api.ts"
import { createFetchClient } from "@zayne-labs/callapi";
import { metricsPlugin, envPlugin, loggingPlugin } from "./plugins";

const callBackendApi = createFetchClient({
	plugins: [envPlugin, loggingPlugin],
});

const { data } = await callBackendApi("/users", {
	plugins: ({ basePlugins }) => [...basePlugins, metricsPlugin], // Add metrics plugin while keeping base plugins
});
```

## Example: Metrics Plugin

Here's a complete example of a plugin that tracks API metrics:

```ts title="plugins.ts"
import { definePlugin } from "@zayne-labs/callapi";

declare module "@zayne-labs/callapi" {
	interface Register {
		meta: {
			startTime: number;
		};
	}
}

const metricsPlugin = definePlugin({
	id: "metrics",
	name: "Metrics Plugin",
	description: "Tracks API response times and success rates",

	setup: ({ initURL, options }) => {
		console.info(`Starting request to ${initURL}`);

		const startTime = performance.now();

		return {
			options: {
				...options,
				meta: { startTime },
			},
		};
	},

	hooks: {
		onSuccess: ({ options }) => {
			const startTime = options.meta?.startTime ?? 0;
			const duration = performance.now() - startTime;

			console.info(`Request completed in ${duration}ms`);
		},

		onError: ({ error, options }) => {
			const startTime = options.meta?.startTime ?? 0;
			const duration = performance.now() - startTime;

			console.error(`Request failed after ${duration}ms:`, error);
		},
	},
});
```

## Types

<auto-type-table path="../../lib/callapi-options.ts" name="CallApiPlugin" />
