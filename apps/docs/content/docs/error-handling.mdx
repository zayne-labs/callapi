---
title: Error Handling
description: Learn more about how to handle errors in CallApi
icon: ShieldAlert
---

It's prevalent knowledge that making network requests is inherently risky. Things can go wrong for many reasons:

- The server might be down.
- The server might respond with an error status like 404 Not Found (the resource doesn't exist) or 500 Internal Server Error (something broke on the server).
- There might be a network issue.
- The request might timeout.
- The response data might not be in the format you expected (e.g., not valid JSON).

When using the standard browser fetch API, handling these failures can sometimes be a bit clunky due to the following reasons:

- Network errors throw one type of error
- Non-2xx HTTP responses don't throw errors by default (you have to check response.ok)
- Parsing errors might throw yet another type

This can lead to complex if/else chains and unwieldy try...catch blocks just to figure out what went wrong.

CallApi aims to make dealing with these failures much more predictable and convenient.

## Structure of the `error` property

As introduced in the [Getting Started](/docs/getting-started) guide, CallApi wraps responses in a result object with three key properties: `data`, `error`, and `response`.

When something goes wrong while making a request, the `error` property will contain a structured object detailing the problem.

The `error` property is an object that has the following properties:

1. **name**: A string identifying the type of error (e.g., `'HTTPError'`, `'ValidationError'`, `'TypeError'`, `'TimeoutError'`, ...etc).

2. **message**: A brief description of what went wrong:
   - For HTTP errors: The error message from the server, or if not provided, falls back to the `defaultHTTPErrorMessage` option
   - For validation errors: A formatted error message derived from the validation issues array
   - For non-HTTP errors: The error message from the JavaScript error object that caused the error

3. **errorData**: The detailed error information:
   - For HTTP errors: It is set to the `parsed error response from the API`
   - For validation errors: It is set to the `validation issues array`
   - For non-HTTP errors: It is set to `false`

4. **originalError**: The original error object that caused the error:
   - For HTTP errors: `HTTPError`
   - For validation errors: `ValidationError`
   - For non-HTTP errors: The underlying javascript error object (e.g., `TypeError`, `DOMException`, etc.)

```ts twoslash title="api.ts"
import { callApi } from "@zayne-labs/callapi";

const { error } = await callApi("https://my-api.com/api/v1/session");
// @annotate: Hover over the error object to see the type
```

## Handling HTTP Errors (HTTPError)

One of the most common types of errors you'll encounter is when the server responds with a status code outside the 200-299 range (like 400, 401, 403, 404, 500, 503, etc.). Standard `fetch` doesn't throw an error for these responses.

CallApi, by default, wraps these responses in an `HTTPError`.
You can customize the error response data type by providing a second generic type argument to callApi.

```ts twoslash title="api.ts"
import { callApi } from "@zayne-labs/callapi";

type ErrorData = {
	errors: Array<string | string[]>;
	message: string;
};

const { error } = await callApi<unknown, ErrorData>("/api/endpoint");

if (error) {
	console.log(error.errorData);
}
```

Since the `error` property is a discriminated union, you can use the `isHTTPError` utility from `@zayne-labs/callapi/utils` to check if it's an HTTP error:

```ts twoslash title="api.ts"
import { callApi } from "@zayne-labs/callapi";
import { isHTTPError } from "@zayne-labs/callapi/utils";

type UserData = {
	completed: boolean;
	id: number;
	title: string;
	userId: string;
};

type ErrorResponseData = {
	errors?: Array<string | string[]>;
	message?: string;
};

const { data, error } = await callApi<UserData, ErrorResponseData>("https://my-api.com/api/v1/session");

if (isHTTPError(error)) {
	console.error(error);
	console.error(error.name); // 'HTTPError'
	console.error(error.message);
	console.error(error.errorData); // Will be set to the error response data
}
```

## Handling Validation Errors (ValidationError)

While covered in more detail in the [Validation](/docs/validation) section, CallApi also has built-in support for schema validation.
If you configure a schema (whether for any request option or for the response data) and the received data does not match that schema, CallApi will wrap this failure in a `ValidationError`.

You can use the `isValidationError` utility to check specifically for this error type:

```ts twoslash title="api.ts"
import { callApi } from "@zayne-labs/callapi";
import { isValidationError } from "@zayne-labs/callapi/utils";
import { z } from "zod";

const dataSchema = z.object({
	id: z.number(),
	userId: z.string(),
	title: z.string(),
	completed: z.boolean(),
});

const { data, error } = await callApi("https://my-api.com/api/v1/session", {
	schema: {
		data: dataSchema,
	},
});

if (isValidationError(error)) {
	console.error(error);
	console.error(error.name); // 'ValidationError'
	console.error(error.message);
	console.error(error.errorData); // Will be set to the validation issues array
}
```

As seen in the case above, if the data received from the API does not match the schema, the `ValidationError` thrown will be captured in the `error` property.

## Handling Thrown Errors

Sometimes you might prefer that errors are thrown instead of returned in the result object. Set `throwOnError` to `true` to enable this behavior.
This is useful when integrating with libraries that expect promises to reject on failure (like TanStack Query).

```ts twoslash title="api.ts"
import { callApi } from "@zayne-labs/callapi";
import { isHTTPErrorInstance, isValidationErrorInstance } from "@zayne-labs/callapi/utils";

type UserData = {
	completed: boolean;
	id: number;
	title: string;
	userId: string;
};

type ErrorResponseData = {
	errors?: Array<string | string[]>;
	message?: string;
};

try {
	const { data } = await callApi<UserData>("https://my-api.com/api/v1/session", {
		throwOnError: true,
	});
} catch (error) {
	if (isHTTPErrorInstance<ErrorResponseData>(error)) {
		console.error(error);
		console.error(error.name);
		console.error(error.message);
		console.error(error.errorData);
	}

	if (isValidationErrorInstance(error)) {
		console.error(error);
		console.error(error.name);
		console.error(error.message);
		console.error(error.errorData);
	}
}
```

**Conditional throwing:**

You can also pass a function to `throwOnError` for conditional throwing based on the error context:

```ts twoslash title="api.ts"
import { callApi } from "@zayne-labs/callapi";
import { isHTTPError, isValidationError } from "@zayne-labs/callapi/utils";

// Only throw for authentication errors
const resultOne = await callApi("https://my-api.com/api/v1/session", {
	throwOnError: ({ response }) => response?.status === 401,
});

// Throw for client errors (user mistakes) but not server errors (temporary issues)
const resultTwo = await callApi("https://my-api.com/api/users", {
	throwOnError: ({ response }) => {
		if (!response) {
			return false;
		}

		return response.status >= 400 && response.status < 500;
	},
});

// Complex conditional logic based on error type and context
const resultThree = await callApi("https://my-api.com/api/sensitive", {
	throwOnError: ({ error, response, options }) => {
		// Always throw validation errors - data integrity is critical
		if (isValidationError(error)) {
			return true;
		}

		// Throw HTTP errors for sensitive endpoints
		if (isHTTPError(error) && response?.status === 403 && options.initURL?.includes("/sensitive")) {
			return true;
		}

		// Throw rate limiting errors during business hours (handle differently off-hours)
		if (response?.status === 429) {
			const hour = new Date().getHours();
			return hour >= 9 && hour <= 17;
		}

		// Return other errors in result object
		return false;
	},
});
```

## The `data` and `error` properties as a discriminated union

Another way to look at the `data` and `error` properties is as a pair of mutually exclusive properties.

This implies that:

- If `error` is present, `data` is null.
- If `error` is null, `data` is present.

TypeScript understands this relationship. So if you check for error first and handle it, TypeScript can automatically narrow the type of `data` to exclude null.

```ts twoslash title="api.ts"
import { callApi } from "@zayne-labs/callapi";
import { isHTTPError } from "@zayne-labs/callapi/utils";

type UserData = {
	completed: boolean;
	id: number;
	title: string;
	userId: string;
};

type ErrorResponseData = {
	errors?: Array<string | string[]>;
	message?: string;
};

const { data, error } = await callApi<UserData, ErrorResponseData>("https://my-api.com/api/v1/session");

if (isHTTPError(error)) {
	console.error(error);
} else if (error) {
	console.error(error);
} else {
	console.log(data); // TypeScript knows data is not null here
}
// @annotate: Hover over the data object to see the narrowed type
```
